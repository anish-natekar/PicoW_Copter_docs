.. PicoW_Copter_Docs documentation master file, created by
   sphinx-quickstart on Tue May  9 16:37:36 2023.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Welcome to PicoW_Copter_Docs's documentation!
=============================================
This is the Official Documentation for the PicoW Copter
The PicoW Copter is an open source micro sub 60g quadcopter that is controlled using WiFi via a smartphone or computer.
The PicoW Copter is designed to be a low cost, easy to build, and fun to fly quadcopter.

Hardware
========

The Hardware required can be found in the Hardware folder of PicoW Copter project.
The Harware folders contains a BOM, PCB gerber files, and STL file for the frame.
The BOM provided contains links for the parts from online indian websites but you can easily find them for other countries as well.

Bill of Materials
-----------------

.. list-table:: BOM
   :widths: 25 25 50
   :header-rows: 1

   * - Part Name 
     - Quantity 
     - Link
   * - Raspberry Pi Pico W 
     - 1 
     - https://robu.in/product/raspberry-pi-pico-w/ |
   * - MPU6050 
     - 1 
     - https://robu.in/product/mpu-6050-gyro-sensor-2-accelerometer/ |
   * - 1S 360mAh Lipo Battery 
     - 1 
     - https://robu.in/product/orange-360-mah-1s-30c-60c-lithium-polymer-battery-pack-lipo/ |
   * - 720 Coreless Motor 
     - 4 
     - https://robu.in/product/8520-magnetic-micro-coreless-motor-for-micro-quadcopters-2xcw-2xccw/ |
   * - 55mm Propeller (included with motors) 
     - 4 
     - https://robu.in/product/8520-magnetic-micro-coreless-motor-for-micro-quadcopters-2xcw-2xccw/ |
   * - si2302 N channel Mosfet 
     - 4 
     - https://www.ktron.in/product/si2302-mosfet-sot23/ |
   * - 1N4007 Diode 
     - 4 
     - https://robu.in/product/1n4148-surface-mount-zener-diode-pack-of-30/ |
   * - Male Pin headers 
     - 44 
     - https://www.ktron.in/product/header-pins-40x1-2-54mm-pitch-brass/ |
   * - Female Pin headers 
     - 40 
     - https://www.ktron.in/product/berg-strip-female-2-54mm-brass/ |
   * - XH male connector 
     - 1 
     - https://www.ktron.in/product/2pin-jst-xh-male-connector/ |
   * - Push Button 
     - 1 
     - https://www.ktron.in/product/3x6x2-5mm-tactile-switch-smd/ |
   * - BMP 280 
     - 1 
     - https://robu.in/product/bmp280-barometric-pressure-and-altitude-sensor-i2c-spi-module/ |
   * - 1S Lipo charger 
     - 1 
     - https://robu.in/product/4-port-dc5v-1s-rc-lithium-lipo-battery-compact-balance-charger-rc-quadcopter/ |

Taking Rs 160 for 1 PCB and Rs 160 for 3D printed frame from an online service.
The total cost of the hardware is just above 2000 INR or 30 USD.

.. note::
    Most of the hardware won't be available in small quantities so it is adviced to anyone lloking to build this project to try to build multiple of them either for yourself or a group of friends.

PCB
---

.. image::
    images/PCB.png
    :width: 80%
    :align: center
    :alt: PCB

The PCB Gerber files are given in the *PCB_Gerber_PicoW_Copter* folder.
The PCB is a double layered, 4cm X 6cm, 1oz copper, 1.6mm PCB. 

.. image::
  images/Schematic_PicoW_Copter.png
  :width: 100%
  :align: center
  :alt: Schematic

Testing
=======

Testing script are not only useful to test individual hardware components of the PicoW Copter
but also a great way to learn how individual components work.
This project is complex but extremely affordable allowing room for errors and mistakes even for complete beginners.
Anyone looking to modify the code and hardware is more than welcome to do so. 

Receiver
--------

The PicoW Copter uses the onboard infenion WiFi chip of the raspberry Pi PicoW to communicate with a device (smartphone or computer) through UDP packets.
The static IP address when using the Pi Pico over access point mode (hotspot mode) is 192.168.1.42 by default.  
The main motivation for using UDP is real time control of the PicoW Copter. The time taken to read packets is around 200 microseconds.


.. code-block:: arduino
  :linenos:

  #include <WiFi.h>
  #include <WiFiUdp.h>

  #ifndef APSSID
  #define APSSID "PicoW"    // name of your PicoW Hotspot
  #define APPSW "password" // password of your PicoW Hotspot
  #endif
  #define UDP_PKT_MAX_SIZE 16 //  number of characters in a UDP packet

  unsigned int localPort = 8888;  // local port for UDP communication
  char packetBuffer[UDP_PKT_MAX_SIZE + 1];  // max number of characters received in one message
  int Throttle, Roll, Pitch, Yaw; // values received from each channel
  int prev;

  WiFiUDP Udp; // Object for WIFI UDP class

  void setup() {
    Serial.begin(115200);
    WiFi.mode(WIFI_AP); // Access Point mode
    WiFi.begin(APSSID, APPSW);  // By default static IP for PicoW will be 192.168.42.1
    while(WiFi.status() != WL_CONNECTED) {
      Serial.print('.');  // waiting for connection
      delay(500); // 0.5 sec delay
    }    
    Serial.print("\nConnected! IP address: ");
    Serial.println(WiFi.localIP());   // The IP Address is 192.168.42.1
    Serial.printf("UDP server on port %d\n", localPort);  // Port is 8888
    Udp.begin(localPort); // start listening on port 8888
  }

  void loop() {
    // if there is data available to read then read a packet
    int packetSize = Udp.parsePacket();
    if(packetSize) {  // if packet size is > 0
      prev = micros();
      int n = Udp.read(packetBuffer, UDP_PKT_MAX_SIZE); // read the data from UDP packet into packetBuffer
      packetBuffer[n] = '\0'; // character for end of string
      char ch1[5], ch2[5], ch3[5], ch4[5];  // 
      ch1[4] = '\0'; ch2[4] = '\0'; ch3[4] = '\0'; ch4[4] = '\0';
      for(int i=0; i<4; i++) {
        // Spliting the packets into four values of 4 characters each
        ch1[i] = packetBuffer[i];
        ch2[i] = packetBuffer[i+4];
        ch3[i] = packetBuffer[i+8];
        ch4[i] = packetBuffer[i+12];            
      }    
      // converting string/character arrays to integer
      Yaw = atoi(ch1);
      Throttle = atoi(ch2);
      Roll = atoi(ch3);
      Pitch = atoi(ch4);    
      Serial.printf("Yaw = %d, Throttle = %d, Roll = %d, Pitch = %d\n", Yaw, Throttle, Roll, Pitch);
      Serial.printf("Time taken = %d\n", micros() - prev);
    }   
  }

The UDP packets are sent by an APP or software (in our case this python code) on the device to the PicoW's IP address and port number provided in the Receiver.ino file.

.. code-block:: python
  :linenos:

  import socket
  import time

  UDP_IP = "192.168.1.42"
  UDP_PORT = 8888
  MESSAGE = "1000100110021003" # sending four 4 digit long numbers

  # creating a UDP socket (UDP is connection less)
  server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  while True:
      server.sendto(MESSAGE.encode('utf-8'), (UDP_IP, UDP_PORT))
      # sleep for 1 second
      time.sleep(1)

Gyro
----

The MPU6050 is a 6 axis gyroscope and accelerometer sensor. It is used to measure the orientation of the PicoW Copter.
The MPU6050 is connected to the Pi PicoW using I2C protocol communicatin at a frequency of 400kHz. The I2C address of the MPU6050 is 0x68.
All i2c register addresses can be found in the MPU6050 manual by invensense. Joop Brokking has a great tutorial on how to use the MPU6050 with Arduino.

.. code-block:: arduino
  :linenos:

  #include<Wire.h>

  #define I2C_CLK_FREQ 400000 // 400kHz
  const u_int8_t IMUAddress = 0x68;  // Address for MPU6050 IMU sensor
  // IMU offset 
  int16_t gyroXoffset = 0;  
  int16_t gyroYoffset = 0;  
  int16_t gyroZoffset = 0;  
  int16_t accXoffset = 0;   
  int16_t accYoffset = 0;   
  int16_t accZoffset = 0;   
  // MPU6050 IMU 
  int16_t accX, accY, accZ; // accelerometer
  int16_t tempRaw;  
  int16_t gyroX, gyroY, gyroZ; // gyroscope
  float temp; // temperature
  int prev;   // keeps track of time before reading IMU data

  void setup() {
    pinMode(LED_BUILTIN, OUTPUT); // set the built in LED pin as Output
    Serial.begin(115200);
    Wire.setClock(I2C_CLK_FREQ);  // setting I2C communication frequency to 400kHz
    Wire.begin(); // starting I2C communication over SDA0 and SCL0 pins
    
    Wire.beginTransmission(IMUAddress);
    Wire.write(0x6B); // PWR_MGMT_1
    Wire.write(0x00);
    Wire.endTransmission();

    Wire.beginTransmission(IMUAddress);
    Wire.write(0x1B); // GYRO_CONFIG
    Wire.write(0x08); // +- 1000 degrees/s
    Wire.endTransmission();

    Wire.beginTransmission(IMUAddress);
    Wire.write(0x1C); // ACCEL_CONFIG
    Wire.write(0x10); // +- 16g
    Wire.endTransmission();

    Wire.beginTransmission(IMUAddress);
    Wire.write(0x1A); // CONFIG
    Wire.write(0x03);
    Wire.endTransmission();

    // IMU offset calculation
    int offcnt;
    long gx=0, gy=0, gz=0, ax=0, ay=0, az=0;  // variables to store sum of 1000 readings
    for(offcnt=0; offcnt<=1000; offcnt++) {
      // Reading IMU data 1000 times to calculate offset values of IMU
      Wire.beginTransmission(IMUAddress);
      Wire.write(0x3B); // GyroXhigh byte
      Wire.endTransmission();
      Wire.requestFrom(IMUAddress, 14); // request 14 bytes of data from IMU
      while(Wire.available() < 14); // If we have received 14 bytes exit out of loop
      // read IMU data values
      accX = Wire.read()<<8|Wire.read();
      accY = Wire.read()<<8|Wire.read();
      accZ = Wire.read()<<8|Wire.read();
      tempRaw = Wire.read()<<8|Wire.read();
      gyroX = Wire.read()<<8|Wire.read();
      gyroY = Wire.read()<<8|Wire.read();
      gyroZ = Wire.read()<<8|Wire.read();   
      // Sum the values read from IMU
      gx += gyroX;
      gy += gyroY;
      gz += gyroZ;
      ax += accX;
      ay += accY;
      az += accZ;
      delay(3); // simulating delay for rest of the quadcopter processes
      if(offcnt%40 == 0)    
        digitalWrite(LED_BUILTIN, HIGH);  // LED blinks to indicate offset calculation is going on
      else
        digitalWrite(LED_BUILTIN, LOW);
    }  
    // get the average of 1000 readings
    gyroXoffset = (int16_t)(gx/1000);
    gyroYoffset = (int16_t)(gy/1000);
    gyroZoffset = (int16_t)(gz/1000);
    accXoffset = (int16_t)(ax/1000);
    accYoffset = (int16_t)(ay/1000);
    accZoffset = (int16_t)(az/1000);
  }

  void loop() {
    prev = micros();  // record time when we started reading IMU data
    // read IMU values
    Wire.beginTransmission(IMUAddress);
    Wire.write(0x3B);
    Wire.endTransmission();
    Wire.requestFrom(IMUAddress, 14);

    while(Wire.available() < 14);
    
    accX = Wire.read()<<8|Wire.read();
    accY = Wire.read()<<8|Wire.read();
    accZ = Wire.read()<<8|Wire.read();
    tempRaw = Wire.read()<<8|Wire.read();
    gyroX = Wire.read()<<8|Wire.read();
    gyroY = Wire.read()<<8|Wire.read();
    gyroZ = Wire.read()<<8|Wire.read();   
    // subtract offset from readings 
    gyroX -= gyroXoffset;
    gyroY -= gyroYoffset;
    gyroZ -= gyroZoffset;
    accX -= accXoffset;
    accY -= accYoffset;
    accZ -= accZoffset;
    temp = (float)tempRaw;
    // print data
    //Serial.printf("AccX = %d, AccY = %d, AccZ = %d, Temp = ", accX, accY, accZ);
    //Serial.print(temp);  
    //Serial.printf(", GyroX = %d, GyroY = %d, GyroZ = %d\n", gyroX, gyroY, gyroZ);
    Serial.printf("Time = %d\n", micros() - prev);
    delay(250);
  }

BMP280
------

The BMP280 is a barometric pressure and temperature sensor. It is used for the altitude hold feature of the PicoW Copter.
The details for the i2c registers of the BMP280 sensor can be found in the data sheet along with the conversions.
I will suggest those who are interested to refer to the video by Carbon Aeronautics.
(This feature is not tested but a script is provided for getting sensor data for PicoW)

.. code-block:: arduino
  :linenos:

  #include <Wire.h>
  #define BMPAddress 0x76

  // Barometer calibration values
  uint16_t dig_T1, dig_P1;
  int16_t dig_T2, dig_T3, dig_P2, dig_P3, dig_P4, dig_P5;
  int16_t dig_P6, dig_P7, dig_P8, dig_P9;

  // Altitude variables
  float AltitudeBarometer, AltitudeBarometerStartUp;
  int RateCalibrationNumber;

  // read barometer signal
  void barometer_signal() {
    Wire.beginTransmission(BMPAddress);
    Wire.write(0xF7);
    Wire.endTransmission();
    Wire.requestFrom(BMPAddress, 6);
    uint32_t press_msb = Wire.read(); // 0xF7 
    uint32_t press_lsb = Wire.read(); // 0xF8
    uint32_t press_xlsb = Wire.read();
    uint32_t temp_msb = Wire.read();
    uint32_t temp_lsb = Wire.read();  
    uint32_t temp_xlsb = Wire.read(); // 0xFC

    // Construct raw temperature and pressure measurements
    // msb contans bits [19-12], lsb contains bits [11-4], and xlsb contains bits [3-0]
    unsigned long int adc_P = (press_msb<<12)|(press_lsb<<4)|(press_xlsb>>4);
    unsigned long int adc_T = (temp_msb<<12)|(temp_lsb<<4)|(temp_xlsb>>4);

    // Construct fine resolution temperature value
    signed long var1, var2;
    var1 = ((((adc_T>>3)-((signed long int)dig_T1<<1)))*((signed long int)dig_T2))>>11;
    var2 = (((((adc_T>>4) - ((signed long int)dig_T1)) * ((adc_T>>4)-((signed long int)dig_T1)))>>12)*((signed long int)dig_T3))>>14;
    signed long int t_fine = var1 + var2;

    // Construct the compensated and calibrated pressure p according to manufacturer
    unsigned long int p;
    var1 = (((signed long int)t_fine)>>1) - (signed long int)64000;
    var2 = (((var1>>2)*(var1>>2))>>11)*((signed long int)dig_P6);
    var2 = var2 + ((var1*((signed long int)dig_P5))<<1);
    var2 = (var2>>2)+(((signed long int)dig_P4)<<16);
    var1 = (((dig_P3*(((var1>>2)*(var1>>2))>>13))>>3)+((((signed long int)dig_P2)*var1)>>1))>>18;
    var1 = ((((32768+var1))*((signed long int)dig_P1))>>15);
    if(var1 == 0) { p = 0; }
    p = (((unsigned long int)(((signed long int)1048576)-adc_P)-(var2>>12)))*3125;
    if(p<0x80000000) { p = (p<<1) / ((unsigned long int)var1); }
    else { p = (p / (unsigned long int)var1) * 2; }
    var1 = (((signed long int)dig_P9)*((signed long int)(((p>>3)*(p>>3))>>13)))>>12;
    var2 = (((signed long int)(p>>2))*((signed long int)dig_P8))>>13;
    p = (unsigned long int)((signed long int)p + ((var1 + var2 + dig_P7)>>4));

    double pressure = (double)p/100;  // pressure in hPa
    AltitudeBarometer = 44330*(1-pow(pressure/1013.25, 1/5.255))*100; // Altitude in cm
  }

  void setup() {
    // BMP280 setup
    Serial.begin(57600);
    pinMode(LED_BUILTIN, OUTPUT);
    digitalWrite(LED_BUILTIN, HIGH);
    Wire.setClock(400000);
    Wire.begin();
    delay(250);

    // Setup BMP280 barometer optimized for indoor navigation
    Wire.beginTransmission(BMPAddress);
    Wire.write(0xF4); // measurement register setup for indoor mode
    Wire.write(0x57); // normal mode, pressure oversampling x16 temperature oversampling x2
    Wire.endTransmission();   
    // Setup configuration register
    Wire.beginTransmission(BMPAddress);
    Wire.write(0xF5);
    Wire.write(0x14); // IIR filter coefficient 16 rest are 0
    Wire.endTransmission();
    // Importing 12 trimming parameters from sensor
    uint8_t data[24], i = 0;
    // First trimming parameter
    Wire.beginTransmission(BMPAddress);
    Wire.write(0x88);
    Wire.endTransmission();
    Wire.requestFrom(BMPAddress, 24); // 24 bytes of data from register 0x88 to 0x9F
    while(Wire.available()) {
      data[i] = Wire.read();
      i++;
    }    
    dig_T1 = (data[1]<<8) | data[0];
    dig_T2 = (data[3]<<8) | data[2];
    dig_T3 = (data[5]<<8) | data[4];
    dig_P1 = (data[7]<<8) | data[6];
    dig_P2 = (data[9]<<8) | data[8];
    dig_P3 = (data[11]<<8) | data[10];
    dig_P4 = (data[13]<<8) | data[12];
    dig_P5 = (data[15]<<8) | data[14];
    dig_P6 = (data[17]<<8) | data[16];
    dig_P7 = (data[19]<<8) | data[18];
    dig_P8 = (data[21]<<8) | data[20];
    dig_P9 = (data[23]<<8) | data[22];
    delay(250);
    // barometer calibration calculating altitude reference level
    for(RateCalibrationNumber = 0; RateCalibrationNumber<2000; RateCalibrationNumber++) {
      barometer_signal();
      AltitudeBarometerStartUp += AltitudeBarometer;
      delay(1);
    }
    AltitudeBarometerStartUp/=2000;
  }

  void loop() {
    // Read the barometer and print altitudes
    barometer_signal();
    AltitudeBarometer = AltitudeBarometerStartUp;
    Serial.print("Altitude [cm]:");
    Serial.println(AltitudeBarometer);
    delay(50);
  }

Motor control
-------------

The motors are controlled by a PWM signal generated by using analog write command on digital pins.
The Mosfets act as a switch to rapidly switch the voltage and current from the battery to the motors
according to the PWM signal received. The direction of rotation of the coreless dc motors can be changed 
switching the connection of the motor to the flight controller i.e. by switching the polarity.
The direction of rotation for the motors are same as YMFC or Pixhawk/Arducopter quadcopters i.e.
front right CCW, front left CW, bottom right CW and bottom left CCW. This script is not only useful to test the
motors but also test the direction of rotation of the motors.
(waiting for PCB to test script)

Battery voltage
---------------

While flying any quadcopter it is important to keep track of the battery voltage. The battery is a 1S Lipo 360mAh Battery
and it is important to be careful when using Lipo batteries in any project as special care needs to be taken to prevent
over discharge (while flying) and over charge (while charging). If you Lipo looks swollen it is recommended to dispose it in
a controlled manner i.e. first using a large resistance to slowly discharge the Lipo completely and slowly and then burrying it.
This script reads the battery voltage from the A0 pin and sends the reading over WiFi using UDP to another device.



Software
========

The main software contains the flight controller.
(Yet to be tested!)

.. toctree::
  :maxdepth: 2